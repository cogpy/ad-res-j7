# Todo to Issues Generator
# Automatically generates GitHub issues with actionable tasks from files in the todo/ folder

name: Todo to Issues Generator

on:
  push:
    branches: [ "main" ]
    paths: [ "todo/**" ]
  pull_request:
    branches: [ "main" ]
    paths: [ "todo/**" ]
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: 'Force regeneration of all issues (will close existing todo-related issues)'
        required: false
        default: 'false'
        type: boolean

jobs:
  generate-issues:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read       # Required to read repository files
      issues: write        # Required to create and manage issues
      actions: read        # Required to read workflow files
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install glob

      - name: Scan todo folder
        id: scan
        run: |
          echo "=== Todo Folder Analysis ===" >> $GITHUB_STEP_SUMMARY
          
          # Check if todo directory exists
          if [ ! -d "todo" ]; then
            echo "‚ùå Todo directory not found" >> $GITHUB_STEP_SUMMARY
            echo "has_todos=false" >> $GITHUB_OUTPUT
            echo "error=no_todo_directory" >> $GITHUB_OUTPUT
            echo "::warning::Todo directory does not exist"
            exit 0
          fi
          
          # Count todo files with error handling
          if todo_count=$(find todo -name "*.md" 2>/dev/null | wc -l); then
            echo "üìÇ Found $todo_count todo files" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Failed to scan todo directory" >> $GITHUB_STEP_SUMMARY
            echo "has_todos=false" >> $GITHUB_OUTPUT
            echo "error=scan_failed" >> $GITHUB_OUTPUT
            echo "::error::Failed to scan todo directory"
            exit 1
          fi
          
          if [ $todo_count -eq 0 ]; then
            echo "‚ö†Ô∏è No todo files found - nothing to process" >> $GITHUB_STEP_SUMMARY
            echo "has_todos=false" >> $GITHUB_OUTPUT
            echo "todo_count=0" >> $GITHUB_OUTPUT
          else
            echo "has_todos=true" >> $GITHUB_OUTPUT
            echo "todo_count=$todo_count" >> $GITHUB_OUTPUT
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üìã **Todo Files Found:**" >> $GITHUB_STEP_SUMMARY
            
            # List files with error handling
            find todo -name "*.md" 2>/dev/null | while read -r file; do
              if [ -f "$file" ]; then
                file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "unknown")
                echo "- \`$file\` (${file_size} bytes)" >> $GITHUB_STEP_SUMMARY
              fi
            done
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Ready to process $todo_count todo files" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create issue generator script
        if: steps.scan.outputs.has_todos == 'true'
        run: |
          cat > issue-generator.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const glob = require('glob');

          class TodoIssueGenerator {
            constructor() {
              this.issues = [];
              this.existingIssues = new Set();
            }

            // Parse markdown content to extract actionable items
            parseMarkdownForTasks(content, filename) {
              const lines = content.split('\n');
              const tasks = [];
              let currentSection = '';
              let currentPriority = 'medium';
              let inPrioritySection = false;
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Track current section for context
                if (line.match(/^#{1,4}\s+/)) {
                  currentSection = line.replace(/^#+\s+/, '');
                  
                  // Extract priority from section headers
                  if (line.toLowerCase().includes('critical') || line.toLowerCase().includes('priority 1')) {
                    currentPriority = 'critical';
                  } else if (line.toLowerCase().includes('high') || line.toLowerCase().includes('priority 2')) {
                    currentPriority = 'high';
                  } else if (line.toLowerCase().includes('medium') || line.toLowerCase().includes('priority 3')) {
                    currentPriority = 'medium';
                  } else if (line.toLowerCase().includes('low') || line.toLowerCase().includes('priority 4')) {
                    currentPriority = 'low';
                  }
                  
                  // Check if we're in a priority recommendation section
                  inPrioritySection = line.toLowerCase().includes('priority recommendations') ||
                                    line.toLowerCase().includes('must-do') ||
                                    line.toLowerCase().includes('should-do') ||
                                    line.toLowerCase().includes('nice-to-have') ||
                                    line.toLowerCase().includes('phase 1') ||
                                    line.toLowerCase().includes('phase 2') ||
                                    line.toLowerCase().includes('phase 3') ||
                                    line.toLowerCase().includes('phase 4');
                }
                
                // Look for numbered tasks in priority sections
                if (inPrioritySection) {
                  const numberedTask = line.match(/^\d+\.\s*(.+)$/);
                  if (numberedTask) {
                    const task = numberedTask[1].trim();
                    if (task.length > 10) {
                      tasks.push({
                        task: task,
                        section: currentSection,
                        priority: this.determinePriorityFromSection(currentSection),
                        file: filename,
                        lineNumber: i + 1,
                        type: 'priority_task'
                      });
                    }
                  }
                }
                
                // Look for specific actionable patterns
                const actionablePatterns = [
                  /^-\s*(.*(?:implement|add|create|fix|update|improve|enhance|develop|build|establish|provide|include|demonstrate|expand|complete|review).*)/i,
                  /^\*\s*(.*(?:implement|add|create|fix|update|improve|enhance|develop|build|establish|provide|include|demonstrate|expand|complete|review).*)/i
                ];
                
                for (const pattern of actionablePatterns) {
                  const match = line.match(pattern);
                  if (match) {
                    const task = match[1].trim();
                    
                    if (this.isHighQualityTask(task)) {
                      tasks.push({
                        task: task,
                        section: currentSection,
                        priority: currentPriority,
                        file: filename,
                        lineNumber: i + 1,
                        type: 'actionable_item'
                      });
                    }
                    break;
                  }
                }
                
                // Look for specific recommendation sections
                if (line.includes('**Improvements Needed**:') || 
                    line.includes('**Action Required**:') ||
                    line.includes('**Recommended Actions**:')) {
                  
                  // Next lines likely contain tasks
                  for (let j = i + 1; j < Math.min(i + 10, lines.length); j++) {
                    const nextLine = lines[j].trim();
                    
                    if (nextLine.startsWith('-')) {
                      const taskMatch = nextLine.match(/^-\s*(.+)$/);
                      if (taskMatch) {
                        const taskText = taskMatch[1].trim();
                        if (this.isHighQualityTask(taskText)) {
                          tasks.push({
                            task: taskText,
                            section: currentSection,
                            priority: currentPriority,
                            file: filename,
                            lineNumber: j + 1,
                            type: 'improvement_item'
                          });
                        }
                      }
                    } else if (nextLine.length === 0) {
                      continue;
                    } else if (nextLine.match(/^#{1,6}\s+/) || nextLine.includes('**')) {
                      break;
                    }
                  }
                }
              }
              
              return tasks;
            }

            // Determine priority from section name
            determinePriorityFromSection(section) {
              const sectionLower = section.toLowerCase();
              
              if (sectionLower.includes('must-do') || sectionLower.includes('phase 1') || sectionLower.includes('critical')) {
                return 'critical';
              } else if (sectionLower.includes('should-do') || sectionLower.includes('phase 2') || sectionLower.includes('high')) {
                return 'high';
              } else if (sectionLower.includes('nice-to-have') || sectionLower.includes('phase 3') || sectionLower.includes('phase 4')) {
                return 'medium';
              }
              
              return 'medium';
            }

            // Determine if a task is high quality and actionable
            isHighQualityTask(task) {
              // Skip if too short
              if (task.length < 15) {
                return false;
              }
              
              // Skip formatting artifacts and non-actionable text
              const skipPatterns = [
                /^\*\*.*\*\*$/,  // Just bold text
                /^\*\*.*\*\*:$/,  // Bold text ending with colon (section headers)
                /^\*\*Current Coverage\*\*:/i,  // Bold "Current Coverage:" with text after
                /^Current Coverage/i,  // Any line starting with "Current Coverage"
                /^Legal Significance:/i,
                /^Framework Phase:/i,
                /^Impact:/i,
                /^Estimated effort:/i,
                /^Total.*effort:/i,
                /^When compared against/i,
                /^The (current|existing|draft)/i,
                /^This (document|analysis|section)/i,
                /^Improvements? Needed:?$/i,  // Section header pattern
                /^Actions? Required:?$/i,     // Section header pattern
                /^Recommended Actions?:?$/i,  // Section header pattern
                /hours?$/i,  // Ends with "hours" - likely effort estimate
                /^Show\s+/i,  // Lines starting with "Show" - usually examples
                /^Demonstrate\s+/i,  // Lines starting with "Demonstrate" - usually descriptions
                /^Provide\s+/i,  // Lines starting with "Provide" - often descriptive
                /^Include\s+/i,  // Lines starting with "Include" - often descriptive
                /^Emphasize\s+/i,  // Lines starting with "Emphasize" - descriptive
                /^Highlight\s+/i,  // Lines starting with "Highlight" - descriptive
                /^Reference\s+/i,  // Lines starting with "Reference" - descriptive
                /^Expose\s+/i,  // Lines starting with "Expose" - descriptive
                /\(.*\)$/,  // Lines ending with parentheses - often annotations
                /^\[x\]/i,  // Completed checkbox items
                /‚úÖ/,  // Lines with checkmark emoji
                /COMPLETED/i,  // Lines marked as completed
                /^-\s*\*\*/,  // Bullet points starting with bold text
                /^\d+\.\s*\*\*/  // Numbered lists starting with bold text
              ];
              
              for (const pattern of skipPatterns) {
                if (pattern.test(task)) {
                  return false;
                }
              }
              
              // Skip lines that are just descriptions or analysis statements
              const descriptionPatterns = [
                /^.*your .* role/i,
                /^.*Peter's .*/i,
                /^.*timing correlation/i,
                /^.*director loan account/i,
                /^.*historical context/i,
                /^.*industry.?standard/i,
                /^.*sudden objection/i,
                /^.*established practice/i,
                /^.*comprehensive analysis/i,
                /^.*external validation/i,
                /^.*bad faith/i,
                /^.*point.?by.?point/i,
                /^.*general refutation/i,
                /^.*business norms/i,
                /^.*loan account credit/i,
                /^.*director.*owe/i,
                /^.*inconsistent with/i,
                /^.*participation in/i,
                /^.*informal model/i,
                /^.*partially addressed/i,
                /^.*accounting records/i,
                /^.*pretext evidence/i
              ];
              
              for (const pattern of descriptionPatterns) {
                if (pattern.test(task)) {
                  return false;
                }
              }
              
              // Only accept if it's clearly a TODO or action item
              const actionPatterns = [
                /^(TODO|FIXME|TASK|ACTION):/i,
                /^(Implement|Create|Build|Fix|Add|Update|Develop)\s+a\s+/i,
                /^(Write|Draft|Prepare|Design|Setup|Configure)\s+/i,
                /^(Test|Validate|Verify|Check)\s+/i,
                /monitoring and alerting/i,
                /automated testing pipeline/i,
                /comprehensive test suite/i,
                /duplicate prevention/i,
                /JSON parsing/i,
                /workflow functionality/i
              ];
              
              const hasExplicitAction = actionPatterns.some(pattern => 
                pattern.test(task)
              );
              
              return hasExplicitAction;
            }

            // Generate GitHub issue content with improved duplicate prevention
            generateIssueContent(task) {
              const labels = ['todo', 'enhancement'];
              
              // Add priority labels
              if (task.priority === 'critical') {
                labels.push('priority: critical', 'bug');
              } else if (task.priority === 'high') {
                labels.push('priority: high');
              } else if (task.priority === 'medium') {
                labels.push('priority: medium');
              } else if (task.priority === 'low') {
                labels.push('priority: low');
              }

              // Generate a clean title with improved deduplication
              let title = task.task;
              
              // Remove markdown formatting
              title = title.replace(/\*\*(.+?)\*\*/g, '$1');
              title = title.replace(/\*(.+?)\*/g, '$1');
              title = title.replace(/`(.+?)`/g, '$1');
              
              // Trim and clean
              title = title.replace(/^[-*\d.\s]+/, '').trim();
              
              // Add context for better uniqueness when titles are similar
              if (this.titleExists(title)) {
                const contextSuffix = ` (${task.section.replace(/[^a-zA-Z0-9]/g, '').substring(0, 10)})`;
                if (title.length + contextSuffix.length <= 80) {
                  title += contextSuffix;
                } else {
                  title = title.substring(0, 80 - contextSuffix.length) + contextSuffix;
                }
              }
              
              // Limit length
              if (title.length > 80) {
                title = title.substring(0, 77) + '...';
              }
              
              // Track this title for duplicate prevention
              this.existingIssues.add(this.normalizeTitle(title));

              const body = '## Task Description\\n\\n' +
                task.task + '\\n\\n' +
                '## Context\\n\\n' +
                '**Source File:** `' + task.file + '`\\n' +
                '**Section:** ' + task.section + '\\n' +
                '**Priority:** ' + task.priority + '\\n' +
                '**Line:** ' + task.lineNumber + '\\n\\n' +
                '## Implementation Notes\\n\\n' +
                'This task was automatically generated from the todo folder. Please review the source file for additional context and requirements.\\n\\n' +
                '## Acceptance Criteria\\n\\n' +
                '- [ ] Review the task requirements in the source file\\n' +
                '- [ ] Implement the necessary changes\\n' +
                '- [ ] Test the implementation\\n' +
                '- [ ] Update documentation if needed\\n' +
                '- [ ] Close this issue when complete\\n\\n' +
                '---\\n\\n' +
                '*Generated automatically from todo files by GitHub Actions*';

              return {
                title: title,
                body: body,
                labels: labels,
                source: task
              };
            }

            // Helper methods for duplicate prevention
            normalizeTitle(title) {
              return title.toLowerCase()
                .replace(/[^\w\s]/g, '')  // Remove punctuation
                .replace(/\s+/g, ' ')     // Normalize whitespace
                .trim();
            }
            
            titleExists(title) {
              const normalized = this.normalizeTitle(title);
              return this.existingIssues.has(normalized);
            }

            // Process all todo files
            processFiles() {
              console.log('üîÑ Processing todo files for actionable tasks...');
              
              let todoFiles;
              try {
                todoFiles = glob.sync('todo/**/*.md');
                console.log(`Found ${todoFiles.length} todo files to process`);
              } catch (error) {
                console.error('‚ùå Error scanning todo directory:', error.message);
                console.error('Ensure the todo/ directory exists and is accessible');
                process.exit(1);
              }

              if (todoFiles.length === 0) {
                console.log('‚ÑπÔ∏è No todo files found to process');
                return this.issues;
              }

              let totalTasks = 0;
              let processedFiles = 0;
              let failedFiles = [];

              for (const file of todoFiles) {
                console.log(`üìã Processing: ${file}`);
                
                try {
                  // Check file accessibility
                  if (!fs.existsSync(file)) {
                    throw new Error(`File not found: ${file}`);
                  }

                  const stats = fs.statSync(file);
                  if (!stats.isFile()) {
                    throw new Error(`Not a regular file: ${file}`);
                  }

                  // Read file with encoding validation
                  const content = fs.readFileSync(file, 'utf8');
                  
                  if (!content || content.trim() === '') {
                    console.log(`  ‚ö†Ô∏è Skipping empty file: ${file}`);
                    continue;
                  }

                  const tasks = this.parseMarkdownForTasks(content, file);
                  console.log(`  Found ${tasks.length} potential tasks`);
                  
                  for (const task of tasks) {
                    try {
                      const issue = this.generateIssueContent(task);
                      this.issues.push(issue);
                      totalTasks++;
                    } catch (issueError) {
                      console.error(`  ‚ùå Error generating issue for task in ${file}:`, issueError.message);
                      console.error(`  Task content: ${task.task ? task.task.substring(0, 100) : 'N/A'}...`);
                    }
                  }
                  
                  processedFiles++;
                  
                } catch (error) {
                  console.error(`‚ùå Error processing ${file}:`);
                  console.error(`  Error type: ${error.name || 'Unknown'}`);
                  console.error(`  Error message: ${error.message}`);
                  console.error(`  File: ${file}`);
                  
                  failedFiles.push({
                    file: file,
                    error: error.message,
                    type: error.name || 'Unknown'
                  });
                  
                  // Continue processing other files instead of failing completely
                  continue;
                }
              }

              // Report processing results
              console.log(`\nüìä Processing Summary:`);
              console.log(`  ‚úÖ Successfully processed: ${processedFiles} files`);
              console.log(`  ‚ùå Failed to process: ${failedFiles.length} files`);
              console.log(`  üìã Total actionable tasks found: ${totalTasks}`);

              if (failedFiles.length > 0) {
                console.log(`\n‚ö†Ô∏è Files that failed processing:`);
                failedFiles.forEach(failure => {
                  console.log(`  - ${failure.file}: ${failure.error} (${failure.type})`);
                });
              }

              if (processedFiles === 0) {
                console.error('‚ùå No files were successfully processed');
                process.exit(1);
              }

              console.log(`\n‚úÖ Processing complete! Found ${totalTasks} actionable tasks across ${processedFiles} successfully processed files.`);
              return this.issues;
            }

            // Generate output for GitHub Actions with comprehensive validation
            generateOutput() {
              try {
                // Validate issues array before processing
                if (!Array.isArray(this.issues)) {
                  throw new Error('Issues is not an array');
                }
                
                // Validate each issue structure
                const validatedIssues = [];
                for (let i = 0; i < this.issues.length; i++) {
                  const issue = this.issues[i];
                  
                  // Validate required fields
                  if (!issue.title || typeof issue.title !== 'string') {
                    console.warn(`Issue ${i}: Invalid or missing title, skipping`);
                    continue;
                  }
                  
                  if (!issue.body || typeof issue.body !== 'string') {
                    console.warn(`Issue ${i}: Invalid or missing body, skipping`);
                    continue;
                  }
                  
                  if (!Array.isArray(issue.labels)) {
                    console.warn(`Issue ${i}: Invalid labels array, fixing`);
                    issue.labels = ['todo', 'enhancement'];
                  }
                  
                  if (!issue.source || typeof issue.source !== 'object') {
                    console.warn(`Issue ${i}: Invalid source object, skipping`);
                    continue;
                  }
                  
                  // Sanitize and validate title
                  issue.title = issue.title.trim();
                  if (issue.title.length === 0) {
                    console.warn(`Issue ${i}: Empty title after trimming, skipping`);
                    continue;
                  }
                  
                  // Validate and sanitize labels
                  issue.labels = issue.labels.filter(label => 
                    typeof label === 'string' && 
                    label.trim().length > 0 && 
                    label.length <= 50
                  );
                  
                  if (issue.labels.length === 0) {
                    issue.labels = ['todo', 'enhancement'];
                  }
                  
                  validatedIssues.push(issue);
                }
                
                console.log(`‚úÖ Validated ${validatedIssues.length} of ${this.issues.length} issues`);
                
                const output = {
                  summary: {
                    total_issues: validatedIssues.length,
                    priorities: {
                      critical: validatedIssues.filter(i => i.source && i.source.priority === 'critical').length,
                      high: validatedIssues.filter(i => i.source && i.source.priority === 'high').length,
                      medium: validatedIssues.filter(i => i.source && i.source.priority === 'medium').length,
                      low: validatedIssues.filter(i => i.source && i.source.priority === 'low').length
                    },
                    files_processed: [...new Set(validatedIssues.map(i => i.source ? i.source.file : 'unknown').filter(f => f !== 'unknown'))].length,
                    validation_summary: {
                      original_count: this.issues.length,
                      validated_count: validatedIssues.length,
                      skipped_count: this.issues.length - validatedIssues.length
                    }
                  },
                  issues: validatedIssues,
                  generated_at: new Date().toISOString(),
                  generator_version: '2.1',
                  schema_version: '1.0'
                };

                // Final validation of output structure
                if (!output.issues || !Array.isArray(output.issues)) {
                  throw new Error('Invalid issues array in output after validation');
                }
                
                if (!output.summary || typeof output.summary !== 'object') {
                  throw new Error('Invalid summary object in output');
                }

                // Validate JSON serializability
                let outputJSON;
                try {
                  outputJSON = JSON.stringify(output, null, 2);
                } catch (jsonError) {
                  throw new Error(`JSON serialization failed: ${jsonError.message}`);
                }
                
                // Validate JSON can be parsed back
                try {
                  JSON.parse(outputJSON);
                } catch (parseError) {
                  throw new Error(`JSON validation failed: ${parseError.message}`);
                }
                
                // Write to file for GitHub Actions to use
                try {
                  fs.writeFileSync('todo-issues.json', outputJSON);
                  console.log('‚úÖ Successfully wrote output to todo-issues.json');
                  
                  // Verify file was written correctly
                  const verification = fs.readFileSync('todo-issues.json', 'utf8');
                  JSON.parse(verification); // This will throw if file is corrupted
                  console.log('‚úÖ Output file verification passed');
                  
                } catch (writeError) {
                  console.error('‚ùå Failed to write output file:', writeError.message);
                  throw writeError;
                }
                
                return output;
                
              } catch (error) {
                console.error('‚ùå Error generating output:', error.message);
                console.error('Stack trace:', error.stack);
                
                // Create minimal fallback output
                const fallbackOutput = {
                  summary: {
                    total_issues: 0,
                    priorities: { critical: 0, high: 0, medium: 0, low: 0 },
                    files_processed: 0
                  },
                  issues: [],
                  generated_at: new Date().toISOString(),
                  error: error.message
                };
                
                fs.writeFileSync('todo-issues.json', JSON.stringify(fallbackOutput, null, 2));
                throw error;
              }
            }
          }

          // Run the generator with comprehensive error handling
          try {
            console.log('üöÄ Starting Todo Issue Generator...');
            
            const generator = new TodoIssueGenerator();
            const issues = generator.processFiles();
            const output = generator.generateOutput();

            console.log(`\nüìä Final Summary:`);
            console.log(`- Total actionable tasks: ${output.summary.total_issues}`);
            console.log(`- Critical priority: ${output.summary.priorities.critical}`);
            console.log(`- High priority: ${output.summary.priorities.high}`);
            console.log(`- Medium priority: ${output.summary.priorities.medium}`);
            console.log(`- Low priority: ${output.summary.priorities.low}`);
            console.log(`- Files processed: ${output.summary.files_processed}`);
            console.log(`- Generated at: ${output.generated_at}`);

            if (output.summary.total_issues === 0) {
              console.log('\n‚ö†Ô∏è No actionable tasks found. This could indicate:');
              console.log('  - Todo files don\'t contain recognizable task patterns');
              console.log('  - Tasks don\'t meet quality filtering criteria');
              console.log('  - Files are empty or contain only non-actionable content');
              process.exit(0);
            }

            console.log('\nüéâ Todo Issue Generator completed successfully!');
            process.exit(0);
            
          } catch (error) {
            console.error('\nüí• Fatal Error in Todo Issue Generator:');
            console.error(`Error type: ${error.name || 'Unknown'}`);
            console.error(`Error message: ${error.message}`);
            console.error(`Stack trace: ${error.stack}`);
            
            // Ensure we have some output file for GitHub Actions
            const errorOutput = {
              summary: {
                total_issues: 0,
                priorities: { critical: 0, high: 0, medium: 0, low: 0 },
                files_processed: 0
              },
              issues: [],
              generated_at: new Date().toISOString(),
              error: {
                type: error.name || 'Unknown',
                message: error.message,
                stack: error.stack
              }
            };
            
            try {
              fs.writeFileSync('todo-issues.json', JSON.stringify(errorOutput, null, 2));
            } catch (writeError) {
              console.error('‚ùå Failed to write error output:', writeError.message);
            }
            
            process.exit(1);
          }
          EOF

      - name: Parse todo files for actionable tasks
        if: steps.scan.outputs.has_todos == 'true'
        run: |
          echo "üöÄ Parsing todo files for actionable tasks..."
          
          # Run the generator with error handling
          if ! node issue-generator.js; then
            echo "‚ùå Issue generator failed with exit code: $?"
            echo "üìã Checking for partial results..."
            
            if [ -f "todo-issues.json" ]; then
              echo "‚ö†Ô∏è Partial results found - attempting to continue with available data"
              
              # Check if the file contains valid JSON
              if ! jq empty todo-issues.json 2>/dev/null; then
                echo "‚ùå Generated JSON is invalid - creating empty result"
                echo '{"summary":{"total_issues":0,"priorities":{"critical":0,"high":0,"medium":0,"low":0},"files_processed":0},"issues":[],"error":"Generator failed with invalid JSON output"}' > todo-issues.json
              fi
            else
              echo "‚ùå No output file generated - creating empty result"
              echo '{"summary":{"total_issues":0,"priorities":{"critical":0,"high":0,"medium":0,"low":0},"files_processed":0},"issues":[],"error":"Generator failed to produce output"}' > todo-issues.json
            fi
            
            echo "::warning::Issue generator encountered errors but workflow will continue"
          else
            echo "‚úÖ Issue generator completed successfully"
          fi

      - name: Load generated issues
        if: steps.scan.outputs.has_todos == 'true'
        id: load_issues
        run: |
          echo "üìÑ Loading and validating generated issues..."
          
          if [ ! -f "todo-issues.json" ]; then
            echo "‚ùå Output file todo-issues.json not found"
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "error=output_file_missing" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No output file generated - check previous step for errors" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # Validate JSON structure with comprehensive schema checking
          if ! jq empty todo-issues.json 2>/dev/null; then
            echo "‚ùå Invalid JSON in todo-issues.json"
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "error=invalid_json" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Generated file contains invalid JSON" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # Validate required JSON schema structure
          echo "üîç Validating JSON schema structure..."
          schema_errors=()
          
          # Check for required top-level fields
          if ! jq -e '.summary' todo-issues.json >/dev/null 2>&1; then
            schema_errors+=("Missing 'summary' field")
          fi
          
          if ! jq -e '.issues' todo-issues.json >/dev/null 2>&1; then
            schema_errors+=("Missing 'issues' field")
          fi
          
          # Check if issues is an array
          if ! jq -e '.issues | type == "array"' todo-issues.json >/dev/null 2>&1; then
            schema_errors+=("'issues' field is not an array")
          fi
          
          # Check summary structure
          if ! jq -e '.summary.total_issues' todo-issues.json >/dev/null 2>&1; then
            schema_errors+=("Missing 'summary.total_issues' field")
          fi
          
          if ! jq -e '.summary.priorities' todo-issues.json >/dev/null 2>&1; then
            schema_errors+=("Missing 'summary.priorities' field")
          fi
          
          # Report schema validation results
          if [ ${#schema_errors[@]} -gt 0 ]; then
            echo "‚ùå JSON schema validation failed:"
            for error in "${schema_errors[@]}"; do
              echo "  - $error"
            done
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "error=invalid_json_schema" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Generated JSON does not match expected schema" >> $GITHUB_STEP_SUMMARY
            exit 0
          else
            echo "‚úÖ JSON schema validation passed"
          fi
          
          # Extract data with robust error checking and fallbacks
          if ! issue_count=$(jq -r '.summary.total_issues // 0' todo-issues.json 2>/dev/null); then
            echo "‚ùå Failed to extract issue count from JSON - attempting recovery"
            # Try alternative parsing approaches
            if issue_count=$(jq -r 'if .summary then .summary.total_issues else 0 end' todo-issues.json 2>/dev/null); then
              echo "‚úÖ Recovered issue count using alternative parsing: $issue_count"
            elif issue_count=$(jq -r 'if .issues then (.issues | length) else 0 end' todo-issues.json 2>/dev/null); then
              echo "‚úÖ Recovered issue count by counting issues array: $issue_count"
            else
              echo "‚ùå All JSON parsing recovery attempts failed"
              echo "has_issues=false" >> $GITHUB_OUTPUT
              echo "error=json_parsing_failed" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Failed to parse issue count from generated data after recovery attempts" >> $GITHUB_STEP_SUMMARY
              exit 0
            fi
          fi
          
          # Check for errors in the generated data
          if error_msg=$(jq -r '.error // empty' todo-issues.json 2>/dev/null) && [ -n "$error_msg" ]; then
            echo "‚ö†Ô∏è Generator reported error: $error_msg"
            echo "generator_error=$error_msg" >> $GITHUB_OUTPUT
          fi
          
          echo "issue_count=$issue_count" >> $GITHUB_OUTPUT
          
          if [ "$issue_count" -gt 0 ]; then
            echo "has_issues=true" >> $GITHUB_OUTPUT
            
            # Extract priority counts with robust error handling
            if critical_count=$(jq -r '.summary.priorities.critical // 0' todo-issues.json 2>/dev/null); then
              echo "‚úÖ Critical count extracted: $critical_count"
            else
              critical_count=0
              echo "‚ö†Ô∏è Failed to extract critical count, defaulting to 0"
            fi
            
            if high_count=$(jq -r '.summary.priorities.high // 0' todo-issues.json 2>/dev/null); then
              echo "‚úÖ High count extracted: $high_count"
            else
              high_count=0
              echo "‚ö†Ô∏è Failed to extract high count, defaulting to 0"
            fi
            
            if medium_count=$(jq -r '.summary.priorities.medium // 0' todo-issues.json 2>/dev/null); then
              echo "‚úÖ Medium count extracted: $medium_count"
            else
              medium_count=0
              echo "‚ö†Ô∏è Failed to extract medium count, defaulting to 0"
            fi
            
            if low_count=$(jq -r '.summary.priorities.low // 0' todo-issues.json 2>/dev/null); then
              echo "‚úÖ Low count extracted: $low_count"
            else
              low_count=0
              echo "‚ö†Ô∏è Failed to extract low count, defaulting to 0"
            fi
            
            if files_processed=$(jq -r '.summary.files_processed // 0' todo-issues.json 2>/dev/null); then
              echo "‚úÖ Files processed extracted: $files_processed"
            else
              files_processed=0
              echo "‚ö†Ô∏è Failed to extract files processed, defaulting to 0"
            fi
            
            if generated_at=$(jq -r '.generated_at // "unknown"' todo-issues.json 2>/dev/null); then
              echo "‚úÖ Generated timestamp extracted: $generated_at"
            else
              generated_at="unknown"
              echo "‚ö†Ô∏è Failed to extract timestamp, using 'unknown'"
            fi
            
            # Add summary to GitHub Actions summary
            echo "=== Issue Generation Results ===" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üìä **Generated Issues Summary:**" >> $GITHUB_STEP_SUMMARY
            echo "- **Total Issues:** $issue_count" >> $GITHUB_STEP_SUMMARY
            echo "- **Critical Priority:** $critical_count" >> $GITHUB_STEP_SUMMARY
            echo "- **High Priority:** $high_count" >> $GITHUB_STEP_SUMMARY
            echo "- **Medium Priority:** $medium_count" >> $GITHUB_STEP_SUMMARY
            echo "- **Low Priority:** $low_count" >> $GITHUB_STEP_SUMMARY
            echo "- **Files Processed:** $files_processed" >> $GITHUB_STEP_SUMMARY
            echo "- **Generated At:** $generated_at" >> $GITHUB_STEP_SUMMARY
            
            if [ -n "$error_msg" ]; then
              echo "- **‚ö†Ô∏è Generator Warning:** $error_msg" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Ready to create GitHub issues" >> $GITHUB_STEP_SUMMARY
          else
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No actionable tasks found in todo files" >> $GITHUB_STEP_SUMMARY
            
            if [ -n "$error_msg" ]; then
              echo "Error reported by generator: $error_msg" >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Create GitHub issues
        if: steps.load_issues.outputs.has_issues == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìù Creating GitHub issues from actionable tasks..."
          
          # Verify GitHub CLI and authentication
          if ! command -v gh &> /dev/null; then
            echo "‚ùå GitHub CLI not found"
            exit 1
          fi
          
          if ! gh auth status &> /dev/null; then
            echo "‚ùå GitHub CLI authentication failed"
            echo "Please check GITHUB_TOKEN permissions"
            exit 1
          fi
          

          
          # Function to safely extract JSON field with error handling
          safe_jq_extract() {
            local json="$1"
            local field="$2"
            local default="$3"
            
            if result=$(echo "$json" | jq -r "$field" 2>/dev/null) && [ "$result" != "null" ] && [ -n "$result" ]; then
              echo "$result"
            else
              echo "$default"
            fi
          }
          
          # Check if force regeneration is requested
          force_regenerate="${{ github.event.inputs.force_regenerate }}"
          
          if [ "$force_regenerate" = "true" ]; then
            echo "üîÑ Force regeneration requested - closing existing todo-related issues..."
            
            # Get existing issues with todo label with error handling
            if existing_issues=$(gh api repos/${{ github.repository }}/issues?labels=todo --paginate 2>/dev/null | jq -r '.[].number' 2>/dev/null); then
              issue_count=$(echo "$existing_issues" | wc -w)
              echo "Found $issue_count existing todo issues to close"
              
              for issue_number in $existing_issues; do
                if [ -n "$issue_number" ] && [ "$issue_number" != "null" ]; then
                  echo "üîí Closing existing issue #$issue_number"
                  if ! gh api repos/${{ github.repository }}/issues/$issue_number \
                    --method PATCH \
                    --field state='closed' \
                    --field state_reason='completed' > /dev/null 2>&1; then
                    echo "  ‚ö†Ô∏è Failed to close issue #$issue_number"
                  fi
                fi
              done
            else
              echo "‚ö†Ô∏è Failed to retrieve existing issues - continuing with creation"
            fi
          fi
          
          # Validate issues JSON structure
          if ! jq -e '.issues | type == "array"' todo-issues.json > /dev/null 2>&1; then
            echo "‚ùå Invalid issues array in todo-issues.json"
            exit 1
          fi
          
          issue_array_length=$(jq -r '.issues | length' todo-issues.json 2>/dev/null || echo 0)
          echo "Processing $issue_array_length issues..."
          
          # Initialize counters
          created_count=0
          skipped_count=0
          failed_count=0
          failed_issues=()
          
          # Read and process issues one by one
          for i in $(seq 0 $((issue_array_length - 1))); do
            echo "Processing issue $((i + 1))/$issue_array_length..."
            
            # Extract issue data with comprehensive error handling and validation
            issue=$(jq -c ".issues[$i]" todo-issues.json 2>/dev/null)
            
            if [ -z "$issue" ] || [ "$issue" = "null" ]; then
              echo "  ‚ùå Failed to extract issue $i"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            # Validate individual issue structure
            echo "  üîç Validating issue structure..."
            issue_errors=()
            
            if ! echo "$issue" | jq -e '.title' >/dev/null 2>&1; then
              issue_errors+=("Missing title field")
            fi
            
            if ! echo "$issue" | jq -e '.body' >/dev/null 2>&1; then
              issue_errors+=("Missing body field")
            fi
            
            if ! echo "$issue" | jq -e '.labels' >/dev/null 2>&1; then
              issue_errors+=("Missing labels field")
            fi
            
            if ! echo "$issue" | jq -e '.labels | type == "array"' >/dev/null 2>&1; then
              issue_errors+=("Labels field is not an array")
            fi
            
            if [ ${#issue_errors[@]} -gt 0 ]; then
              echo "  ‚ùå Issue $i failed validation:"
              for error in "${issue_errors[@]}"; do
                echo "    - $error"
              done
              failed_count=$((failed_count + 1))
              continue
            fi
            
            title=$(safe_jq_extract "$issue" '.title' 'Untitled Task')
            body=$(safe_jq_extract "$issue" '.body' 'No description available')
            labels_json=$(safe_jq_extract "$issue" '.labels' '[]')
            
            # Validate extracted data
            if [ -z "$title" ] || [ "$title" = "Untitled Task" ]; then
              echo "  ‚ùå Issue $i has no valid title"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            # Check for duplicate issues (unless force regenerate)
            if [ "$force_regenerate" != "true" ]; then
              # Normalize title for comparison (lowercase, remove punctuation)
              normalized_title=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[[:punct:]]//g' | tr -s ' ')
              
              # Check for exact and similar matches
              if existing=$(gh api "repos/${{ github.repository }}/issues?state=open&per_page=100" --paginate 2>/dev/null | \
                jq -r --arg title "$title" --arg norm_title "$normalized_title" \
                '.[] | select(
                  .title == $title or 
                  (.title | ascii_downcase | gsub("[[:punct:]]"; "") | gsub("\\s+"; " ")) == $norm_title or
                  (.title | startswith($title[0:50])) or
                  ($title | startswith(.title[0:50]))
                ) | .number' 2>/dev/null | head -1); then
                if [ -n "$existing" ] && [ "$existing" != "null" ]; then
                  echo "  ‚ö†Ô∏è Skipping duplicate/similar: $title (exists as #$existing)"
                  skipped_count=$((skipped_count + 1))
                  continue
                fi
              else
                echo "  ‚ö†Ô∏è Failed to check for duplicates, proceeding with creation"
              fi
            fi
            
            # Parse labels array with robust JSON handling and validation
            # GitHub CLI expects individual --label arguments, not a JSON array
            # This safely converts the JSON array ["label1","label2"] to individual --label arguments
            gh_args=("issue" "create" "--title" "$title" "--body" "$body")
            
            echo "  üè∑Ô∏è Processing labels: $labels_json"
            
            if [ "$labels_json" != "[]" ] && [ "$labels_json" != "null" ]; then
              # Validate labels JSON structure
              if ! echo "$labels_json" | jq -e 'type == "array"' >/dev/null 2>&1; then
                echo "  ‚ö†Ô∏è Labels field is not a valid JSON array, attempting to fix..."
                # Try to extract labels from malformed JSON
                if labels_fixed=$(echo "$labels_json" | jq -c 'if type == "string" then [.] else . end' 2>/dev/null); then
                  labels_json="$labels_fixed"
                  echo "  ‚úÖ Fixed labels JSON structure"
                else
                  echo "  ‚ùå Could not fix labels JSON, using empty array"
                  labels_json="[]"
                fi
              fi
              
              # Process each label with error handling
              label_count=0
              while IFS= read -r label; do
                if [ -n "$label" ] && [ "$label" != "null" ]; then
                  # Validate label format (GitHub label requirements)
                  if [[ "$label" =~ ^[a-zA-Z0-9:\ ._-]+$ ]] && [ ${#label} -le 50 ]; then
                    gh_args+=("--label" "$label")
                    label_count=$((label_count + 1))
                    echo "    ‚úÖ Added label: '$label'"
                  else
                    echo "    ‚ö†Ô∏è Skipped invalid label: '$label' (invalid format or too long)"
                  fi
                fi
              done < <(echo "$labels_json" | jq -r '.[]' 2>/dev/null || echo "")
              
              echo "  üìä Processed $label_count valid labels"
              
              # Ensure minimum required labels
              if [ $label_count -eq 0 ]; then
                echo "  ‚ö†Ô∏è No valid labels found, adding default labels"
                gh_args+=("--label" "todo")
                gh_args+=("--label" "enhancement")
              fi
            else
              echo "  ‚ö†Ô∏è No labels provided, adding default labels"
              gh_args+=("--label" "todo")
              gh_args+=("--label" "enhancement")
            fi
            
            echo "  ‚úÖ Creating: $(echo "$title" | cut -c1-50)..."
            
            # Create the issue using gh with proper argument array (no eval needed)
            if gh "${gh_args[@]}" > /dev/null 2>&1; then
              echo "    ‚úÖ Successfully created issue"
              created_count=$((created_count + 1))
            else
              echo "    ‚ùå Failed to create issue"
              failed_count=$((failed_count + 1))
              failed_issues+=("$title")
            fi
            
            # Add small delay to avoid rate limiting
            sleep 1
          done
          
          # Generate comprehensive summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìù **Issue Creation Results:**" >> $GITHUB_STEP_SUMMARY
          echo "- **‚úÖ Created:** $created_count issues" >> $GITHUB_STEP_SUMMARY
          echo "- **‚ö†Ô∏è Skipped:** $skipped_count duplicates" >> $GITHUB_STEP_SUMMARY
          echo "- **‚ùå Failed:** $failed_count issues" >> $GITHUB_STEP_SUMMARY
          echo "- **üìä Total Processed:** $((created_count + skipped_count + failed_count)) issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Report failed issues if any
          if [ $failed_count -gt 0 ]; then
            echo "‚ùå **Failed Issues:**" >> $GITHUB_STEP_SUMMARY
            for failed_title in "${failed_issues[@]}"; do
              echo "- $failed_title" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Final status message
          if [ $created_count -gt 0 ]; then
            echo "üéâ Successfully created $created_count GitHub issues from todo files!" >> $GITHUB_STEP_SUMMARY
            echo "üìã Check the Issues tab to view and manage the generated tasks." >> $GITHUB_STEP_SUMMARY
          elif [ $skipped_count -gt 0 ]; then
            echo "‚ÑπÔ∏è No new issues created - all tasks already have corresponding issues" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è No issues were created - check the logs above for errors" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Set appropriate exit code
          if [ $failed_count -gt 0 ] && [ $created_count -eq 0 ]; then
            echo "::warning::Some issues failed to create but workflow completed"
          fi

      - name: Report workflow failures
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Gather failure information
            const failureContext = {
              workflow: 'todo-to-issues',
              trigger: context.eventName,
              branch: context.ref,
              commit: context.sha,
              actor: context.actor,
              runId: context.runId,
              runUrl: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              timestamp: new Date().toISOString(),
              repository: `${context.repo.owner}/${context.repo.repo}`
            };
            
            // Read any available error logs or outputs
            let errorDetails = 'Workflow failed during execution.';
            let todoStats = {};
            
            try {
              if (fs.existsSync('todo-issues.json')) {
                const todoData = JSON.parse(fs.readFileSync('todo-issues.json', 'utf8'));
                if (todoData.error) {
                  errorDetails = `Generator Error: ${todoData.error}`;
                }
                todoStats = todoData.summary || {};
              }
            } catch (error) {
              console.log('Could not read todo-issues.json for error details');
            }
            
            // Create failure issue
            const issueTitle = `Todo-to-Issues Workflow Failure - ${failureContext.timestamp.split('T')[0]}`;
            const issueBody = `## üö® Workflow Failure Alert
            
            The **todo-to-issues** workflow has failed and requires immediate attention.
            
            ### Failure Details
            - **Workflow**: ${failureContext.workflow}
            - **Trigger**: ${failureContext.trigger}
            - **Branch**: ${failureContext.branch}
            - **Commit**: ${failureContext.commit}
            - **Actor**: ${failureContext.actor}
            - **Timestamp**: ${failureContext.timestamp}
            
            ### Error Information
            ${errorDetails}
            
            ### Todo Processing Stats
            ${todoStats.total_issues ? `- Total Issues to Create: ${todoStats.total_issues}` : '- Todo processing may have failed'}
            ${todoStats.files_processed ? `- Files Processed: ${todoStats.files_processed}` : ''}
            ${todoStats.priorities ? `- Critical Priority: ${todoStats.priorities.critical}` : ''}
            ${todoStats.priorities ? `- High Priority: ${todoStats.priorities.high}` : ''}
            
            ### Impact Assessment
            - ‚ö†Ô∏è **Critical**: Todo tasks may not be converted to GitHub issues
            - ‚ö†Ô∏è **User Impact**: New todo items won't be tracked automatically
            - ‚ö†Ô∏è **Process**: Manual issue creation may be required
            
            ### Immediate Actions Required
            1. üîç **Investigate**: Check the workflow run logs: [View Run](${failureContext.runUrl})
            2. üîß **Fix**: Address any syntax errors or permission issues
            3. üß™ **Test**: Run workflow manually after fixes
            4. üìã **Verify**: Ensure todo files are being processed correctly
            
            ### Monitoring Information
            - **Workflow Run**: [${failureContext.runId}](${failureContext.runUrl})
            - **Repository**: ${failureContext.repository}
            - **Triggered by**: ${failureContext.trigger}
            
            ---
            
            *This issue was created automatically by the workflow monitoring system. Please investigate and resolve the failure promptly.*
            `;
            
            // Check for existing failure issues to prevent spam
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['workflow-failure', 'todo-to-issues'],
              per_page: 5
            });
            
            const recentFailure = existingIssues.data.find(issue => {
              const issueDate = new Date(issue.created_at);
              const hoursSinceIssue = (new Date() - issueDate) / (1000 * 60 * 60);
              return hoursSinceIssue < 24; // Only check last 24 hours
            });
            
            if (!recentFailure) {
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: ['workflow-failure', 'todo-to-issues', 'bug', 'priority: high']
              });
              
              console.log(`Created failure alert issue: ${newIssue.data.html_url}`);
            } else {
              // Add comment to existing issue instead of creating new one
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: recentFailure.number,
                body: `## üîÑ Additional Failure Detected
                
                Another failure occurred in the todo-to-issues workflow.
                
                **Time**: ${failureContext.timestamp}
                **Trigger**: ${failureContext.trigger}
                **Run**: [${failureContext.runId}](${failureContext.runUrl})
                **Error**: ${errorDetails}
                
                Please investigate this recurring failure pattern.`
              });
              
              console.log(`Added comment to existing failure issue: ${recentFailure.html_url}`);
            }

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "üßπ Cleaning up temporary files..."
          
          # Remove temporary files with error handling
          for file in issue-generator.js todo-issues.json; do
            if [ -f "$file" ]; then
              if rm -f "$file" 2>/dev/null; then
                echo "  ‚úÖ Removed $file"
              else
                echo "  ‚ö†Ô∏è Failed to remove $file"
              fi
            else
              echo "  ‚ÑπÔ∏è $file not found (already cleaned up)"
            fi
          done
          
          echo "üßπ Cleanup completed"