# File Representation Validator
# Ensures every file has both markdown and JSON representations

name: File Representation Validator

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  validate-and-generate:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write      # Required to commit and push generated files
      actions: read        # Required to read workflow files
      checks: read         # Required to read check results
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install glob

      - name: Create analysis script
        run: |
          cat > analyze-files.js << 'EOF'
          const fs = require('fs');
          const glob = require('glob');
          
          console.log('=== Repository File Analysis ===');
          
          // Find all files
          const mdFiles = glob.sync('**/*.md', { 
            ignore: ['node_modules/**', 'vendor/**', 'bower_components/**', 'jspm_packages/**', '.bundle/**', 'target/**', 'build/**', 'dist/**', '.git/**', 'README.md'] 
          });
          const jsonFiles = glob.sync('**/*.json', { 
            ignore: ['node_modules/**', 'vendor/**', 'bower_components/**', 'jspm_packages/**', '.bundle/**', 'target/**', 'build/**', 'dist/**', '.git/**', 'package*.json'] 
          });
          
          console.log(`📊 **File Statistics**`);
          console.log(`- Markdown files: ${mdFiles.length}`);
          console.log(`- JSON files: ${jsonFiles.length}`);
          console.log('');
          
          // Check for missing pairs
          let missing_json = 0;
          let missing_md = 0;
          let missingJsonList = [];
          let missingMdList = [];
          
          console.log('🔍 **Missing JSON representations:**');
          for (const mdFile of mdFiles) {
            const jsonFile = mdFile.replace(/\.md$/, '.json');
            if (!fs.existsSync(jsonFile)) {
              console.log(`- \`${jsonFile}\` (for \`${mdFile}\`)`);
              missingJsonList.push({md: mdFile, json: jsonFile});
              missing_json++;
            }
          }
          
          if (missing_json === 0) {
            console.log('- ✅ All markdown files have JSON representations');
          }
          
          console.log('');
          console.log('🔍 **Missing Markdown representations:**');
          for (const jsonFile of jsonFiles) {
            const mdFile = jsonFile.replace(/\.json$/, '.md');
            if (!fs.existsSync(mdFile)) {
              console.log(`- \`${mdFile}\` (for \`${jsonFile}\`)`);
              missingMdList.push({json: jsonFile, md: mdFile});
              missing_md++;
            }
          }
          
          if (missing_md === 0) {
            console.log('- ✅ All JSON files have markdown representations');
          }
          
          console.log('');
          console.log('📈 **Summary:**');
          console.log(`- Missing JSON files: ${missing_json}`);
          console.log(`- Missing MD files: ${missing_md}`);
          
          // Write outputs for GitHub Actions
          fs.writeFileSync('missing_json_count.txt', missing_json.toString());
          fs.writeFileSync('missing_md_count.txt', missing_md.toString());
          
          console.log(`\nAnalysis complete. Missing pairs: JSON=${missing_json}, MD=${missing_md}`);
          EOF

      - name: Analyze existing file representations
        id: analyze
        run: |
          echo "=== Repository File Analysis ===" >> $GITHUB_STEP_SUMMARY
          node analyze-files.js >> $GITHUB_STEP_SUMMARY
          
          # Read the counts from files created by Node.js script  
          missing_json=$(cat missing_json_count.txt)
          missing_md=$(cat missing_md_count.txt)
          
          echo "missing_json=$missing_json" >> $GITHUB_OUTPUT
          echo "missing_md=$missing_md" >> $GITHUB_OUTPUT

      - name: Create file converter script
        run: |
          cat > file-converter.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const glob = require('glob');

          class FileConverter {
            constructor() {
              this.conversions = 0;
            }

            // Convert markdown content to structured JSON
            markdownToJson(mdContent, filePath) {
              const lines = mdContent.split('\n');
              const result = {
                title: '',
                source_file: path.resolve(filePath),
                created_at: new Date().toISOString(),
                file_type: 'markdown',
                sections: []
              };

              let currentSection = null;
              let currentSubsection = null;
              let currentContent = [];

              for (const line of lines) {
                // Extract title from first heading
                if (line.match(/^#\s+/) && !result.title) {
                  result.title = line.substring(1).trim();
                  continue;
                }

                // Handle headings
                const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
                if (headingMatch) {
                  const level = headingMatch[1].length;
                  const heading = headingMatch[2].trim();

                  // Save previous content
                  if (currentSubsection) {
                    currentSubsection.content = currentContent.join('\n').trim();
                  } else if (currentSection) {
                    currentSection.content = currentContent.join('\n').trim();
                  }
                  currentContent = [];

                  if (level === 2) {
                    // New main section
                    if (currentSection) {
                      result.sections.push(currentSection);
                    }
                    currentSection = {
                      heading: heading,
                      level: level,
                      content: '',
                      subsections: []
                    };
                    currentSubsection = null;
                  } else if (level >= 3 && currentSection) {
                    // New subsection
                    if (currentSubsection) {
                      currentSection.subsections.push(currentSubsection);
                    }
                    currentSubsection = {
                      heading: heading,
                      level: level,
                      content: ''
                    };
                  }
                } else {
                  // Regular content line
                  currentContent.push(line);
                }
              }

              // Save final content
              if (currentSubsection) {
                currentSubsection.content = currentContent.join('\n').trim();
                if (currentSection) currentSection.subsections.push(currentSubsection);
              } else if (currentSection) {
                currentSection.content = currentContent.join('\n').trim();
              }

              if (currentSection) {
                result.sections.push(currentSection);
              }

              // If no structured sections found, put all content in a single section
              if (result.sections.length === 0 && lines.length > 0) {
                result.sections.push({
                  heading: result.title || 'Document Content',
                  level: 2,
                  content: lines.join('\n').trim(),
                  subsections: []
                });
              }

              return result;
            }

            // Convert JSON content to markdown
            jsonToMarkdown(jsonContent) {
              let markdown = '';
              
              try {
                const data = typeof jsonContent === 'string' ? JSON.parse(jsonContent) : jsonContent;
                
                // Add title
                if (data.title) {
                  markdown += `# ${data.title}\n\n`;
                }

                // Add metadata if it's a converted file
                if (data.source_file || data.created_at) {
                  markdown += `<!-- Generated from JSON representation -->\n`;
                  if (data.source_file) markdown += `<!-- Source: ${data.source_file} -->\n`;
                  if (data.created_at) markdown += `<!-- Created: ${data.created_at} -->\n`;
                  markdown += `\n`;
                }

                // Add sections
                if (data.sections && Array.isArray(data.sections)) {
                  for (const section of data.sections) {
                    if (section.heading) {
                      const level = section.level || 2;
                      markdown += `${'#'.repeat(level)} ${section.heading}\n\n`;
                    }
                    
                    if (section.content) {
                      markdown += `${section.content}\n\n`;
                    }

                    // Add subsections
                    if (section.subsections && Array.isArray(section.subsections)) {
                      for (const subsection of section.subsections) {
                        if (subsection.heading) {
                          const level = subsection.level || 3;
                          markdown += `${'#'.repeat(level)} ${subsection.heading}\n\n`;
                        }
                        if (subsection.content) {
                          markdown += `${subsection.content}\n\n`;
                        }
                      }
                    }
                  }
                } else {
                  // Fallback: show JSON as code block
                  markdown += `## Data\n\n\`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\`\n\n`;
                }

                return markdown;
              } catch (error) {
                console.error('JSON parsing error:', error);
                // Fallback for invalid JSON
                return `# JSON Document\n\n\`\`\`json\n${jsonContent}\n\`\`\`\n`;
              }
            }

            // Process all files and generate missing representations
            processFiles() {
              console.log('🔄 Starting file conversion process...');
              
              // Find all files
              const mdFiles = glob.sync('**/*.md', { 
                ignore: ['node_modules/**', 'vendor/**', 'bower_components/**', 'jspm_packages/**', '.bundle/**', 'target/**', 'build/**', 'dist/**', '.git/**', 'README.md'] 
              });
              const jsonFiles = glob.sync('**/*.json', { 
                ignore: ['node_modules/**', 'vendor/**', 'bower_components/**', 'jspm_packages/**', '.bundle/**', 'target/**', 'build/**', 'dist/**', '.git/**', 'package*.json'] 
              });

              console.log(`Found ${mdFiles.length} markdown files and ${jsonFiles.length} JSON files`);

              // Convert MD to JSON for missing JSON files
              for (const mdFile of mdFiles) {
                const jsonFile = mdFile.replace(/\.md$/, '.json');
                if (!fs.existsSync(jsonFile)) {
                  try {
                    const mdContent = fs.readFileSync(mdFile, 'utf8');
                    const jsonData = this.markdownToJson(mdContent, mdFile);
                    
                    // Ensure directory exists
                    const dir = path.dirname(jsonFile);
                    if (!fs.existsSync(dir)) {
                      fs.mkdirSync(dir, { recursive: true });
                    }
                    
                    fs.writeFileSync(jsonFile, JSON.stringify(jsonData, null, 2));
                    console.log(`✅ Generated JSON: ${jsonFile}`);
                    this.conversions++;
                  } catch (error) {
                    console.error(`❌ Error converting ${mdFile}:`, error.message);
                  }
                }
              }

              // Convert JSON to MD for missing MD files
              for (const jsonFile of jsonFiles) {
                const mdFile = jsonFile.replace(/\.json$/, '.md');
                if (!fs.existsSync(mdFile)) {
                  try {
                    const jsonContent = fs.readFileSync(jsonFile, 'utf8');
                    const mdData = this.jsonToMarkdown(jsonContent);
                    
                    // Ensure directory exists
                    const dir = path.dirname(mdFile);
                    if (!fs.existsSync(dir)) {
                      fs.mkdirSync(dir, { recursive: true });
                    }
                    
                    fs.writeFileSync(mdFile, mdData);
                    console.log(`✅ Generated MD: ${mdFile}`);
                    this.conversions++;
                  } catch (error) {
                    console.error(`❌ Error converting ${jsonFile}:`, error.message);
                  }
                }
              }

              return this.conversions;
            }
          }

          // Run the conversion
          const converter = new FileConverter();
          const totalConversions = converter.processFiles();
          console.log(`\n🎉 Conversion complete! Generated ${totalConversions} files.`);

          // Exit with appropriate code
          process.exit(0);
          EOF

      - name: Generate missing file representations
        run: |
          echo "🚀 Generating missing file representations..."
          node file-converter.js

      - name: Configure Git
        run: |
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Commit and push changes
        run: |
          # Check if there are any changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "✅ No new files needed - all representations already exist!"
            echo "status=no-changes" >> $GITHUB_ENV
          else
            git add -A
            git status
            
            # Count the changes
            added_files=$(git diff --staged --name-only | wc -l)
            
            echo "📝 Committing $added_files new file representations..."
            git commit -m "Auto-generate missing file representations
            
            - Generated JSON representations for markdown files
            - Generated markdown representations for JSON files
            - Ensures every file has both MD and JSON formats
            - Files processed: $added_files
            - Automated by GitHub Actions"
            
            echo "status=committed" >> $GITHUB_ENV
            echo "files_added=$added_files" >> $GITHUB_ENV
          fi

      - name: Final validation and summary
        run: |
          cat > final-validation.js << 'EOF'
          const fs = require('fs');
          const glob = require('glob');
          
          console.log('=== Final Repository Analysis ===');
          
          // Find all files
          const mdFiles = glob.sync('**/*.md', { 
            ignore: ['node_modules/**', 'vendor/**', 'bower_components/**', 'jspm_packages/**', '.bundle/**', 'target/**', 'build/**', 'dist/**', '.git/**', 'README.md'] 
          });
          const jsonFiles = glob.sync('**/*.json', { 
            ignore: ['node_modules/**', 'vendor/**', 'bower_components/**', 'jspm_packages/**', '.bundle/**', 'target/**', 'build/**', 'dist/**', '.git/**', 'package*.json'] 
          });
          
          console.log('');
          console.log('📊 **Final Statistics**');
          console.log(`- Total Markdown files: ${mdFiles.length}`);
          console.log(`- Total JSON files: ${jsonFiles.length}`);
          console.log('');
          
          // Final validation check
          let missing_pairs = 0;
          
          for (const mdFile of mdFiles) {
            const jsonFile = mdFile.replace(/\.md$/, '.json');
            if (!fs.existsSync(jsonFile)) {
              console.log(`❌ Still missing JSON: ${jsonFile}`);
              missing_pairs++;
            }
          }
          
          for (const jsonFile of jsonFiles) {
            const mdFile = jsonFile.replace(/\.json$/, '.md');
            if (!fs.existsSync(mdFile)) {
              console.log(`❌ Still missing MD: ${mdFile}`);
              missing_pairs++;
            }
          }
          
          if (missing_pairs === 0) {
            console.log('✅ **SUCCESS**: All files have both markdown and JSON representations!');
            console.log('');
            console.log('🎯 **Repository Compliance**: 100%');
            process.exit(0);
          } else {
            console.log(`❌ **WARNING**: ${missing_pairs} files still missing their counterpart`);
            console.log('');
            console.log('This may indicate an issue with the conversion process.');
            process.exit(1);
          }
          EOF
          
          echo "=== Final Repository Analysis ===" >> $GITHUB_STEP_SUMMARY
          node final-validation.js >> $GITHUB_STEP_SUMMARY

  ocr-and-generate-missing-representations:
    needs: validate-and-generate
    runs-on: ubuntu-latest
    
    permissions:
      contents: write      # Required to commit and push generated files
      actions: read        # Required to read workflow files
      checks: read         # Required to read check results
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js and OCR dependencies
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install Node.js dependencies
        run: npm install glob

      - name: Install OCR dependencies
        run: sudo apt-get update && sudo apt-get install -y tesseract-ocr

      - name: Create OCR file converter script
        run: |
          cat > ocr-file-converter.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const glob = require('glob');
          const { execSync } = require('child_process');

          class OCRFileConverter {
            constructor() {
              this.conversions = 0;
              this.ocrGenerated = 0;
            }

            // Convert markdown content to structured JSON (reuse from main converter)
            markdownToJson(mdContent, filePath) {
              const lines = mdContent.split('\n');
              const result = {
                title: '',
                source_file: path.resolve(filePath),
                created_at: new Date().toISOString(),
                file_type: 'markdown',
                generated_via: 'ocr',
                sections: []
              };

              let currentSection = null;
              let currentSubsection = null;
              let currentContent = [];

              for (const line of lines) {
                // Extract title from first heading
                if (line.match(/^#\s+/) && !result.title) {
                  result.title = line.substring(1).trim();
                  continue;
                }

                // Handle headings
                const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
                if (headingMatch) {
                  const level = headingMatch[1].length;
                  const heading = headingMatch[2].trim();

                  // Save previous content
                  if (currentSubsection) {
                    currentSubsection.content = currentContent.join('\n').trim();
                  } else if (currentSection) {
                    currentSection.content = currentContent.join('\n').trim();
                  }
                  currentContent = [];

                  if (level === 2) {
                    // New main section
                    if (currentSection) {
                      result.sections.push(currentSection);
                    }
                    currentSection = {
                      heading: heading,
                      level: level,
                      content: '',
                      subsections: []
                    };
                    currentSubsection = null;
                  } else if (level >= 3 && currentSection) {
                    // New subsection
                    if (currentSubsection) {
                      currentSection.subsections.push(currentSubsection);
                    }
                    currentSubsection = {
                      heading: heading,
                      level: level,
                      content: ''
                    };
                  }
                } else {
                  // Regular content line
                  currentContent.push(line);
                }
              }

              // Save final content
              if (currentSubsection) {
                currentSubsection.content = currentContent.join('\n').trim();
                if (currentSection) currentSection.subsections.push(currentSubsection);
              } else if (currentSection) {
                currentSection.content = currentContent.join('\n').trim();
              }

              if (currentSection) {
                result.sections.push(currentSection);
              }

              // If no structured sections found, put all content in a single section
              if (result.sections.length === 0 && lines.length > 0) {
                result.sections.push({
                  heading: result.title || 'OCR Document Content',
                  level: 2,
                  content: lines.join('\n').trim(),
                  subsections: []
                });
              }

              return result;
            }

            // Perform OCR on image file
            performOCR(imagePath) {
              try {
                const baseName = path.basename(imagePath, path.extname(imagePath));
                const tempTxtFile = `/tmp/${baseName}.txt`;
                
                console.log(`🧠 Performing OCR on: ${imagePath}`);
                
                // Run tesseract OCR
                execSync(`tesseract "${imagePath}" "/tmp/${baseName}" --dpi 300 -l eng`, { stdio: 'pipe' });
                
                if (fs.existsSync(tempTxtFile)) {
                  const ocrText = fs.readFileSync(tempTxtFile, 'utf8').trim();
                  fs.unlinkSync(tempTxtFile); // Clean up temp file
                  
                  if (ocrText.length > 0) {
                    return ocrText;
                  }
                }
                return null;
              } catch (error) {
                console.error(`❌ OCR failed for ${imagePath}:`, error.message);
                return null;
              }
            }

            // Process image files for missing representations
            processImageFiles() {
              console.log('🔄 Processing image files for OCR conversion...');
              
              // Find all image files
              const imageFiles = glob.sync('**/*.{png,jpg,jpeg,gif,bmp}', { 
                ignore: ['node_modules/**', 'vendor/**', 'bower_components/**', 'jspm_packages/**', '.bundle/**', 'target/**', 'build/**', 'dist/**', '.git/**'] 
              });

              console.log(`Found ${imageFiles.length} image files`);

              if (imageFiles.length === 0) {
                console.log('ℹ️  No image files found - OCR processing not needed');
                return 0;
              }

              for (const imageFile of imageFiles) {
                const baseName = imageFile.replace(/\.(png|jpg|jpeg|gif|bmp)$/i, '');
                const mdFile = `${baseName}.md`;
                const jsonFile = `${baseName}.json`;

                let ocrText = null;

                // Generate missing Markdown file via OCR
                if (!fs.existsSync(mdFile)) {
                  ocrText = ocrText || this.performOCR(imageFile);
                  if (ocrText) {
                    try {
                      // Create markdown content with OCR text
                      const mdContent = `# ${path.basename(baseName)}\n\n<!-- Generated via OCR from ${imageFile} -->\n<!-- Created: ${new Date().toISOString()} -->\n\n## OCR Content\n\n${ocrText}\n`;
                      
                      // Ensure directory exists
                      const dir = path.dirname(mdFile);
                      if (!fs.existsSync(dir)) {
                        fs.mkdirSync(dir, { recursive: true });
                      }
                      
                      fs.writeFileSync(mdFile, mdContent);
                      console.log(`✅ Generated Markdown via OCR: ${mdFile}`);
                      this.ocrGenerated++;
                    } catch (error) {
                      console.error(`❌ Error creating markdown file ${mdFile}:`, error.message);
                    }
                  }
                }

                // Generate missing JSON file via OCR + conversion
                if (!fs.existsSync(jsonFile)) {
                  ocrText = ocrText || this.performOCR(imageFile);
                  if (ocrText) {
                    try {
                      // Create markdown content first
                      const tempMdContent = `# ${path.basename(baseName)}\n\n## OCR Content\n\n${ocrText}\n`;
                      
                      // Convert to JSON structure
                      const jsonData = this.markdownToJson(tempMdContent, imageFile);
                      
                      // Ensure directory exists
                      const dir = path.dirname(jsonFile);
                      if (!fs.existsSync(dir)) {
                        fs.mkdirSync(dir, { recursive: true });
                      }
                      
                      fs.writeFileSync(jsonFile, JSON.stringify(jsonData, null, 2));
                      console.log(`✅ Generated JSON via OCR: ${jsonFile}`);
                      this.ocrGenerated++;
                    } catch (error) {
                      console.error(`❌ Error creating JSON file ${jsonFile}:`, error.message);
                    }
                  }
                }
              }

              return this.ocrGenerated;
            }
          }

          // Run the OCR conversion
          const converter = new OCRFileConverter();
          const totalGenerated = converter.processImageFiles();
          console.log(`\n🎉 OCR processing complete! Generated ${totalGenerated} files from images.`);

          // Exit with appropriate code
          process.exit(0);
          EOF

      - name: Run OCR/Conversion for Missing Markdown/JSON
        run: |
          echo "🚀 Running OCR processing for image files..."
          node ocr-file-converter.js

      - name: Configure Git
        run: |
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Commit and push OCR-generated files
        run: |
          # Check if there are any changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "✅ No OCR files needed - all image representations already exist or no images found!"
            echo "ocr_status=no-changes" >> $GITHUB_ENV
          else
            git add -A
            git status
            
            # Count the changes
            ocr_files=$(git diff --staged --name-only | wc -l)
            
            echo "📝 Committing $ocr_files OCR-generated file representations..."
            git commit -m "Auto-generate missing Markdown/JSON files via OCR/conversion
            
            - Generated Markdown representations from image OCR
            - Generated JSON representations from image OCR + conversion  
            - Ensures image assets have text representations via OCR
            - Files processed: $ocr_files
            - Automated by GitHub Actions OCR workflow"
            
            echo "ocr_status=committed" >> $GITHUB_ENV
            echo "ocr_files_added=$ocr_files" >> $GITHUB_ENV
            
            git push
          fi

      - name: Final OCR validation and summary
        run: |
          echo "=== OCR Processing Summary ===" >> $GITHUB_STEP_SUMMARY
          
          # Count image files and their representations
          image_count=$(find . -type f \( -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.gif" -o -name "*.bmp" \) -not -path "./.git/*" -not -path "./node_modules/*" -not -path "./vendor/*" -not -path "./bower_components/*" -not -path "./jspm_packages/*" -not -path "./.bundle/*" -not -path "./target/*" -not -path "./build/*" -not -path "./dist/*" | wc -l)
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📊 **OCR Processing Results**" >> $GITHUB_STEP_SUMMARY
          echo "- Total image files found: $image_count" >> $GITHUB_STEP_SUMMARY
          
          if [ $image_count -eq 0 ]; then
            echo "- ✅ No image files found - OCR processing not required" >> $GITHUB_STEP_SUMMARY
          else
            echo "- 🧠 OCR processing completed for image assets" >> $GITHUB_STEP_SUMMARY
            echo "- 📝 Generated text representations via Tesseract OCR" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🎯 **Adaptive Job Addition**: Successfully implemented OCR-based generation" >> $GITHUB_STEP_SUMMARY
          echo "📈 **Cognitive Flowchart Compliance**: Recursive implementation pathway completed" >> $GITHUB_STEP_SUMMARY